from collections import Counter
import enum
import re
import CaesarCracker 

"""
repeatedlist = [[repeated(text,i),i] for i in range(100)]




sortedlist = sorted(repeatedlist[1:], reverse=True)
for i,val in enumerate(repeatedlist):
    print("-"*(val[0]))


deg = []
for i,val in enumerate(sortedlist[1:]):
    if (val[0]-sortedlist[i-1][0])/sortedlist[i-1][0] > -.1:
        deg.append(val[1])
    else:
        print("break")
        break
deg = sorted(deg)
results = [deg[i]-deg[i-1] for i in range(1,len(deg))]
results= dict(Counter(results))    
print(results)

print("AAAAAAAAAAAAAAAAA")
"""

COUNTED = "abcdefghijklmnopqrstuvwxyz"

def ngram(n,text):
    counter = []
    amount = 1
    previous = []

    text = text.lower()
    text = ''.join([i for i in text if i in COUNTED])

    for char in text:
        previous.append(char)

        if len(previous) > n:
            previous.pop(0)

        if len(previous) == n:
            counter.append("".join(previous))

    counter = dict(Counter(counter))
    return dict(sorted(counter.items(), key=lambda item: -item[1]))


def kasiski(text):
    repeatedpaterns = []

    tengram = ngram(10,text)
    for patern in tengram:
        if tengram[patern] < 3:
            break
        repeatedpaterns.append(patern)

    sevengram = ngram(7,text)
    for patern in sevengram:
        if sevengram[patern] < 3:
            break
        repeatedpaterns.append(patern)

    fivegram = ngram(5,text)
    for patern in fivegram:
        if fivegram[patern] < 3:
            break
        repeatedpaterns.append(patern)

    deltas = []
    for patern in repeatedpaterns:
        indices = [m.start() for m in re.finditer(patern, text)]
        for i in range(len(indices)-1):
            deltas.append(indices[i+1]-indices[i])

    smallest = sorted(deltas)[0]
    return [i for i in range(2,smallest) if not any(x%i for x in deltas)]



def calculate_IC(text: str) -> int:
    counter = {"a":0,"b":0,"c":0,"d":0,"e":0,"f":0,"g":0,"h":0,"i":0,"j":0,"k":0,"l":0,"m":0,"n":0,"o":0,"p":0,"q":0,"r":0,"s":0,"t":0,"u":0,"v":0,"w":0,"x":0,"y":0,"z":0}
    IC = 0
    
    for char in text:
        if char.lower() in counter:
            counter[char.lower()] +=1

    for char in counter:
        IC+= (counter[char])  *  (counter[char]-1)
    return IC/((len(text)*(len(text)-1))/26)


def repeated(text: str, offset: int):
    return sum(char == text[(i+offset)%len(text)] for i,char in enumerate(text))
    

def crackkeylength(text:str,keyrange:int,debug=False) -> dict:
        
    repeatedlist = [repeated(text,i) for i in range(keyrange*10)]

    if debug:
        for i in range(len(repeatedlist)):
            print("-"*(repeatedlist[i]//10))

    keylengths = {}
    for keylen in range(1,len(repeatedlist)//10):
        peaks=0
        total=0
        for i in range(2,len(repeatedlist)):
            if i%keylen==0:
                peaks+=repeatedlist[i]
                total+=1
        keylengths[keylen] = peaks/total
        #print(f"{keylen}: {peaks/total}")

    return dict(sorted(keylengths.items(), key=lambda item: -item[1]))

def splittext(text:str,keylength:int):
    result = ["" for _ in range(keylength)]
    for index, char in enumerate(text):
        result[index%keylength]+=char
    return result

text = """UIERLELGSHSSXMOZCPPJSALBAGSDXNSXPIGTCHZPRWIWVCRJWOKKIGQRWNYQWOIIKPZHVGFTPHWXDSHTUYAYFZDHHOVSEEKVQAQXYNSMPGEIHPUSIXSTXUSVFSUNFTKZPPMDASVXIJDTSZQPBSYNAGMZVPUUIRUKDPKPMWANHJNLGCXTNKIKRPKLGBQWHVOWDEYPVOLGQURGXUWPQVWNBIJOIMLPAGTKLEGCEGTIMFWFDPPHYDKSZRAGZLRNUXZNGNKVIIZLUVYOSEGZGAASEPSVKFAREEGOKJETNPRPMXSJUXAHIBICMSIYTEEPNDGMMXJYNLPNPTUUIXSVTUSKMRCNSHNZSYATAPPGUWHCIKMPEJAJEZRNIYHORJENAVSYPMGPOHCPIIQLNBMLIEDLIXDIIXCLPLPGIYDOVKNMXAHXZEMRCHWWIFPPBFITGEMVSBPIGASYZDHVHPSWNQWALLVWQVXLVNAQIZWELZMPKELAIFYMGPWHJLLZXZUHFOJTLAIEPIWNAOVTIFDTJVEGNHXALHAJWEOHZPRNXZLHNUNGXUWXZQXRGDADHDIGSOKMENOHEGPIEBSHONLDPOLBHXOEZLRAQXPJGUHWIMPPBYWZDEXLRAMHHYNCFYSMEYQSWIHIEKLXFTHAHLAEZVRXPXRNEEKIIKSAHDRYZPEIHPYRVUEGXLROMEGMSFIPXCIEVDWIHRBMXEQZXBDUNCIILPPRIKENWLVWQLTMSLEYXBISLWQUPGXWPTWXFNSMPPVCKLHHRUOIMCIKXSKNBNACADNWGWNTBUNYQTZLXNZHQNLOICLFRGASMSMXBQXCSYJDGCMWKTERDEKHPWQVBASXAVPZYCPUILLENYMZQWMXSNCTRBSYKSVZSPXSIGHEGEFIKWMEOPTOVYCHXUZHAVTOUYCLEIHZVFHKGEABYKPIFDNCGLROIYUOEXHEMKSKBHTJFMPPPYIGLZHCACAAIKNYBTXYVTGCELUVIZHOHMHOMRWNBILESXLEHZWUFHBQIXZTTJFXQTDZROTSRYCHXUSILMCVCYOELJYOLBLOJWXYHFQXTUUYIPIIKPQIMIHBXNVHQXXWKYNOHVHPSWNQDOHYQBVRANSLXPVBAZBRIAITZLRHAHBPRBAEJZIDACTYPAKYIGTIBMSNAVSHIYIWNCONXUSHWFTASHZPRHSPKSVBORLAQTZLTMRYJKYGOPLBYOTNHVHBSMGPOUJEIIIXLBHKSMHYKXZWHVIONGIMXCVYIKNCEBFCQNHWUYJDTZVLBHSJIEHVOTXQXCJFWRKZRMLDPGNTPLVWZETAVYPDXVXTVBXKBATYRHYHTJFXAZYYPPLFPONGXUEYFIAJZYJEIBIYAKEGLFNBVPMWANHBAPPZJPLGXBIEKLRWQKXISFONLVTAYSWKNTXURNWSGMSUHRIHIPUSZXEUZKIXUKXWZCFVTVWPLBEGNVTUKGQQXWHIAYEGPPUOETDEGMIXEXWRGWDMMEIPUNEZENLASGPQBSBBAPVWICNKSADEHWIGLIBEFCAYHZRHHHMYHEMCEGPETPSYJSIZVWPXOKDAZPOSUIKXBXKXQDNYPSXYDAGCVHAPBSYYCPDDGSASRKNDTAMLSIXWKIJOIMFTQBEGLLXUHBQLBNFVEUIZRKPXRNEBULRFQIKXTGEYHZVUHFITOPLWEKDIGQSCZPHJSCNSFXACAAIGWIGWSHDPXGIGLBLOERXUEEXIGESLDPYBIYGWGNERBUHTFDBSHBWYWCIEMSIYTVTULXFZBSTDWCMBFPZHEGNOGGIKEGAXCFIZKZRXLSZOERXUIGZYBBVYPYMZXXPXRHEDHLPBZKHVZUJRIIFCLSHUVEKVRLIIKTHYLCEOIYDORZWESPNGTMXACGBPINXELJMKREGTETDMDFWFACEGPPLBSVWICGIGPEMFSPWYHVERKIFHELXUHPMVLASXAYLZFMLBXUTFXLWMHMXASHAPRKELYREMENZLPXPIGVWMONLDIYOSFZGEXYZTZHTJUUHXIOIPUSRQELPVSKPSONFBKZVZRDWFIQENOLVDQIKMSHSPMIEYNGXKNDKVIYTIBMSYNDXRICKSVKENHUDXDQXRGDADZZVXPGXJIEMPNWQRLNSHKYWXLFSRMMSPXSPXFNXRBBAEFJWNOJIXDWTHPWIELPSXQCIIHPLSRNEVBNSGIIXAVYXMIIQPLGXKRHHVKAGMSNBYJPIITLHFJRINDLNHZKXWGBWLVDREZHMQDOGRIKQFHBQBSPXZRELJMTDEGLRAMEKESCHTKJROLFHGKGXIVTOLMNBEKCXYELYCTCERWVRSQFXBHYDLRNHZVFIKNOGAZEGGACSHCPZVRRLBIUVEKYSFBIEMSHKAKZWWVHITOPSPNGNINAHCOSEIWRLJSTDEGKSHDFTASHZEIMATQZSTZEWHTIQVXPSGAPROIGLZHCACAAIKNYGISXAYKZZLUUITEWXLVPUWMCSEACOZVPUOPJEZXNIUQYKCSHEDWZRRLJITDEOPIKURZEOHKYWAIPZHIKNBEPNWQVZUOHOOYNZCPSRJENOPIKFZKXCFEUOAIPZHKKNIXADHAZXNZGKRIGMURSRXOEIAEEXIGVSNITNZIYKFMKWEKMLHQVTECINDTVVCLBLKIDXKEOQVXWRAAUYDGSRZSTKOFOSHSHTJFHWXSXLEPSHKRTHHWMQRYUWJGHEHQPANMPNOGGMGSIWRQBPGSJVOLBHGGEGKETDAXARGAHEOSXNSPGCHXUQXQWMNFBKZKCYTGSRNADXLRYQILCZCAOKZHTJVXUPDXDMCLIOJBCJYEVQGHBSXANCLLXFAXARUWYEGPPUIMZGEWLIEPQXEFIQHWKIPSRIUPDXWMTZSXWRUWCOGSYRVIZUIMDIETSGMSLZVIGIYGSKPONZLRLTSXUSOGTWCIEOWIXTOVOZTZHTJUQWEZDICLBAKVRHVPBVOMXQBBPINXPURSADSIHVKQRANWXACWUIVDOQKNWTAKKMEZISTEURJSVGCSRANZOMXDKXFSYOEADNLSZITZICUZKASERXESTNVPWLBDOJNUSMCAQWJHQEUDJSSVIHKNGXSSHRLXCAUWCZMMUVAHGTWBQDHALHDRYJGEIWAHFVKNHXPZTZXCJFCCPWKECYSRNEIPPIPUPGXUYAYWCSZYSRBANPHXAUIKPSVAFVOZLUHPKUKXNISQPERUYSPVFLTLFAURDMUMXFKXTBCADHZRSPSVCORWARBQXZNHLAFVYLTLFAURDXUAXWRTYSHKZONXPYYAKZIMAIGZMXCGNAPHNFTQRIYCHHVPUAIDNBHAPVYEYZDIRENUVIMEIXASHPFMIMPYSRCEWXLVPQDBSBBEPVNXPLRWREUDHEGPIGPOHCMMNIYAWQSERXUZBZHXWKYKZOVPEPXHLIJGKEMGYKCXYEDSHZZVFQKNTFLVDFHTWVUIPVOIYZQLGAFMVQAQXAJFXOEKMSZASRQLEBUHTZAHARNACWOIPKGHACHMPKZQAXAYNILEMEWZVIZVOHYFBVMLWSYIEMZHPYHSIHGKHEZLMCWTLWYWXLZMNMPNMXLXDGRWNGIIMMEHPUYVGAGSVSPUWLNZNDPXRICRVMKRSMLIWEEYKWM"""



keylengths = crackkeylength(text,25)
bestkey = list(keylengths.keys())[:5]
print(bestkey)

inputkeyleng = int(input("keylength: "))

split = splittext(text,inputkeyleng)

keys = []
solvedsplit=[]
for i in split:
    solve= CaesarCracker.caesar_cracker(i)
    keys.append(list(solve.keys())[0])
    solvedsplit.append(solve[list(solve.keys())[0]])

print(keys)
decoded = "".join(solvedsplit[i % inputkeyleng][i // inputkeyleng] for i in range(len(text)))


print(decoded)